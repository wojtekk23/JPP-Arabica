-- Haskell module generated by the BNF converter

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Arabica.Skel where

-- import Prelude (($), Either(..), String, (++), Show, show)
import qualified Arabica.Abs
import qualified Data.Map as M
import Control.Monad.State
import Control.Monad.Reader

import Control.Monad.Trans.Maybe
import Control.Monad.Trans.Except

type VarEnv = M.Map Arabica.Abs.Ident Arabica.Abs.Location
type LocEnv = M.Map Arabica.Abs.Location Arabica.Abs.LocVal
type LocMemory = (LocEnv, Arabica.Abs.Location)
type ExpM a = ReaderT VarEnv Maybe a
type InterpretingMonadIO = ReaderT VarEnv (StateT LocMemory (ExceptT String IO))

type Err = Either String
type Result = InterpretingMonadIO Arabica.Abs.LocVal

errorExpM :: InterpretingMonadIO a
errorExpM = errorInterpretingMonadIO

errorInterpretingMonadIO :: InterpretingMonadIO a
errorInterpretingMonadIO = lift $ lift $ throwE "ERROR"

failure :: Show a => a -> InterpretingMonadIO ()
-- failure x = Left $ "Undefined case: " ++ show x
failure _ = errorInterpretingMonadIO

errorMessage :: String -> InterpretingMonadIO a
errorMessage s = lift $ lift $ throwE s

debugMessage :: String -> InterpretingMonadIO ()
debugMessage s = lift $ lift $ lift $ putStrLn s

newVariable :: Arabica.Abs.Ident -> Arabica.Abs.LocVal -> InterpretingMonadIO VarEnv
newVariable x val = do
  varEnv <- ask
  (locEnv, loc) <- get
  debugMessage $ unwords [show x, show val]
  put $ (M.insert loc val locEnv, loc+1)
  pure $ M.insert x loc varEnv

updateVariable :: Arabica.Abs.Ident -> Arabica.Abs.LocVal -> InterpretingMonadIO ()
updateVariable x val = do
  varEnv <- ask
  (locEnv, lastLoc) <- get
  let addr = M.lookup x varEnv
  case addr of
    Just loc -> put $ (M.insert loc val locEnv, lastLoc)
    Nothing -> errorMessage ("No location found for variable " ++ (show x))

readVariable :: Arabica.Abs.Ident -> InterpretingMonadIO Arabica.Abs.LocVal
readVariable x = do
  varEnv <- ask
  (locEnv, _) <- get
  let addr = M.lookup x varEnv
  case addr of
    Nothing -> errorMessage ("No location found for variable " ++ (show x))
    Just loc -> do
      let maybeVal = M.lookup loc locEnv
      case maybeVal of
        Nothing -> errorMessage (unwords ["Incorrect value for address", show loc, "and variable", show x])
        Just val -> pure val

transIdent :: Arabica.Abs.Ident -> InterpretingMonadIO ()
transIdent x = case x of
  Arabica.Abs.Ident string -> failure x

transProgram :: Arabica.Abs.Program -> InterpretingMonadIO ()
transProgram x = case x of
  Arabica.Abs.Program topdefs -> mapM_ transTopDef topdefs

transTopDef :: Arabica.Abs.TopDef -> InterpretingMonadIO ()
transTopDef x = case x of
  Arabica.Abs.FnDef type_ ident args block -> do
    -- Na razie tylko uruchamiaj main
    let Arabica.Abs.Ident str = ident
    if str /= "main" then pure ()
    else do
      transBlock block
      pure ()

transArg :: Arabica.Abs.Arg -> InterpretingMonadIO ()
transArg x = case x of
  Arabica.Abs.Arg type_ ident -> failure x

noPass :: InterpretingMonadIO (VarEnv, Arabica.Abs.ReturnVal)
noPass = do
  varEnv <- ask
  pure $ (varEnv, Nothing)

transBlock :: Arabica.Abs.Block -> InterpretingMonadIO (VarEnv, Arabica.Abs.ReturnVal)
transBlock x = case x of
  Arabica.Abs.Block stmts -> runStmts stmts
  where
    runStmts [] = noPass
    runStmts (stmt:stmts) = do
      env <- ask
      (locEnv, _) <- get
      debugMessage $ unwords ["VARS", show env]
      debugMessage $ unwords ["LOCS", show locEnv]
      (newVarEnv, _) <- transStmt stmt
      local (const newVarEnv) $ runStmts stmts

transStmt :: Arabica.Abs.Stmt -> InterpretingMonadIO (VarEnv, Arabica.Abs.ReturnVal)
transStmt x = case x of
  Arabica.Abs.Empty -> noPass
  Arabica.Abs.BStmt block -> transBlock block
  Arabica.Abs.Decl type_ items -> do
    -- Na razie tylko int
    case items of
      [] -> noPass
      (x:xs) -> do
        debugMessage $ unwords ["DECL", show (x:xs)]
        (newVarEnv, _) <- transItem x
        local (const newVarEnv) $ transStmt (Arabica.Abs.Decl type_ xs)
  Arabica.Abs.Ass ident expr -> do
    -- env <- get
    -- let locVal = runReaderT (transExpr expr) env
    -- case locVal of
    --   Nothing -> errorInterpretingMonadIO
    --   Just x -> updateVariable ident x
    val <- transExpr expr
    updateVariable ident val
    noPass
  Arabica.Abs.ArrAss ident expr1 expr2 -> errorMessage "ArrAss"
  Arabica.Abs.Incr ident -> errorMessage "Incr"
  Arabica.Abs.Decr ident -> errorMessage "Decr"
  Arabica.Abs.Ret expr -> errorMessage "Ret"
  Arabica.Abs.VRet -> errorMessage "VRet"
  Arabica.Abs.Cond expr stmt -> errorMessage "Cond"
  Arabica.Abs.CondElse expr stmt1 stmt2 -> errorMessage "CondElse"
  Arabica.Abs.While expr stmt -> do
    val <- transExpr expr
    case val of
      Arabica.Abs.BoolVal b -> do
        if b then do
          transStmt stmt
          transStmt x
        else
          noPass
      _ -> errorMessage "while"
  Arabica.Abs.Break -> errorMessage "Break"
  Arabica.Abs.Continue -> errorMessage "Continue"
  Arabica.Abs.SExp expr -> errorMessage "SExp"
  Arabica.Abs.ForTo item expr stmt -> errorMessage "ForTo"
  Arabica.Abs.Print expr -> do
    -- Na razie tylko inty
    val <- transExpr expr
    case val of
      Arabica.Abs.IntegerVal n -> lift $ lift $ lift $ putStrLn $ show n
      _ -> errorMessage "print"
    noPass

transItem :: Arabica.Abs.Item -> InterpretingMonadIO (VarEnv, Arabica.Abs.ReturnVal)
transItem x = case x of
  Arabica.Abs.NoInit ident -> errorMessage "NoInit"
  Arabica.Abs.Init ident expr -> do
    val <- transExpr expr
    newVarEnv <- newVariable ident val
    debugMessage "INIT"
    pure $ (newVarEnv, Nothing)

transType :: Arabica.Abs.Type -> InterpretingMonadIO ()
transType x = case x of
  Arabica.Abs.Int -> failure x
  Arabica.Abs.Str -> failure x
  Arabica.Abs.Bool -> failure x
  Arabica.Abs.Void -> failure x
  Arabica.Abs.Fun type_ types -> failure x
  Arabica.Abs.Array type_ -> failure x

transExpr :: Arabica.Abs.Expr -> InterpretingMonadIO Arabica.Abs.LocVal
transExpr x = case x of
  Arabica.Abs.EArray type_ integer -> errorMessage "Array"
  Arabica.Abs.EArrElem ident expr -> errorMessage "ArrElem"
  Arabica.Abs.ELambda type_ args block -> errorMessage "Lambda"
  Arabica.Abs.EVar ident -> readVariable ident
  Arabica.Abs.ELitInt integer -> pure $ Arabica.Abs.IntegerVal $ integer
  Arabica.Abs.ELitTrue -> pure $ Arabica.Abs.BoolVal $ True
  Arabica.Abs.ELitFalse -> pure $ Arabica.Abs.BoolVal $ False
  Arabica.Abs.EApp ident exprs -> errorMessage "App"
  Arabica.Abs.EString string -> pure $ Arabica.Abs.StringVal $ string
  Arabica.Abs.Neg expr -> do
    Arabica.Abs.IntegerVal n <- transExpr expr
    pure $ Arabica.Abs.IntegerVal $ (-n)
  Arabica.Abs.Not expr -> do
    Arabica.Abs.BoolVal b <- transExpr expr
    pure $ Arabica.Abs.BoolVal $ not b
  Arabica.Abs.EMul expr1 mulop expr2 -> do
    Arabica.Abs.IntegerVal n1 <- transExpr expr1
    Arabica.Abs.IntegerVal n2 <- transExpr expr2
    transMulOp mulop n1 n2
  Arabica.Abs.EAdd expr1 addop expr2 -> do
    Arabica.Abs.IntegerVal n1 <- transExpr expr1
    Arabica.Abs.IntegerVal n2 <- transExpr expr2
    transAddOp addop n1 n2
  Arabica.Abs.ERel expr1 relop expr2 -> do
    Arabica.Abs.IntegerVal n1 <- transExpr expr1
    Arabica.Abs.IntegerVal n2 <- transExpr expr2
    transRelOp relop n1 n2
  Arabica.Abs.EAnd expr1 expr2 -> do
    Arabica.Abs.BoolVal b1 <- transExpr expr1
    Arabica.Abs.BoolVal b2 <- transExpr expr2
    pure $ Arabica.Abs.BoolVal $ b1 && b2
  Arabica.Abs.EOr expr1 expr2 -> do
    Arabica.Abs.BoolVal b1 <- transExpr expr1
    Arabica.Abs.BoolVal b2 <- transExpr expr2
    pure $ Arabica.Abs.BoolVal $ b1 || b2

transAddOp :: Arabica.Abs.AddOp -> Integer -> Integer -> Result
transAddOp x n1 n2 = case x of
  Arabica.Abs.Plus -> pure $ Arabica.Abs.IntegerVal $ n1 + n2
  Arabica.Abs.Minus -> pure $ Arabica.Abs.IntegerVal $ n1 - n2

transMulOp :: Arabica.Abs.MulOp -> Integer -> Integer -> Result
transMulOp x n1 n2 = case x of
  Arabica.Abs.Times -> pure $ Arabica.Abs.IntegerVal $ n1 * n2
  Arabica.Abs.Div -> do
    if n2 == 0 then
      errorMessage "Division by 0"
    else
      pure $ Arabica.Abs.IntegerVal $ n1 `div` n2

transRelOp :: Arabica.Abs.RelOp -> Integer -> Integer -> Result
transRelOp x n1 n2 = case x of
  Arabica.Abs.LTH -> pure $ Arabica.Abs.BoolVal $ n1 < n2
  Arabica.Abs.LE -> pure $ Arabica.Abs.BoolVal $ n1 <= n2
  Arabica.Abs.GTH -> pure $ Arabica.Abs.BoolVal $ n1 > n2
  Arabica.Abs.GE -> pure $ Arabica.Abs.BoolVal $ n1 >= n2
  Arabica.Abs.EQU -> pure $ Arabica.Abs.BoolVal $ n1 == n2
  Arabica.Abs.NE -> pure $ Arabica.Abs.BoolVal $ n1 /= n2
