-- Haskell module generated by the BNF converter

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Arabica.Skel where

-- import Prelude (($), Either(..), String, (++), Show, show)
import qualified Arabica.Abs
import qualified Data.Map as M
import Control.Monad.State
import Control.Monad.Reader

import Control.Monad.Trans.Maybe

type ExpEnv = M.Map Arabica.Abs.Ident Arabica.Abs.LocVal
type ExpM a = ReaderT ExpEnv Maybe a
type InterpretingMonadIO a = StateT ExpEnv (MaybeT IO) a

type Err = Either String
type Result = ExpM Arabica.Abs.LocVal

errorExpM :: ExpM a
errorExpM = lift $ Nothing

errorInterpretingMonadIO :: InterpretingMonadIO a
errorInterpretingMonadIO = lift $ MaybeT $ return Nothing

failure :: Show a => a -> InterpretingMonadIO ()
-- failure x = Left $ "Undefined case: " ++ show x
failure _ = errorInterpretingMonadIO

transIdent :: Arabica.Abs.Ident -> InterpretingMonadIO ()
transIdent x = case x of
  Arabica.Abs.Ident string -> failure x

transProgram :: Arabica.Abs.Program -> InterpretingMonadIO ()
transProgram x = case x of
  Arabica.Abs.Program topdefs -> mapM_ transTopDef topdefs

transTopDef :: Arabica.Abs.TopDef -> InterpretingMonadIO ()
transTopDef x = case x of
  Arabica.Abs.FnDef type_ ident args block -> do
    -- Na razie tylko uruchamiaj main
    let Arabica.Abs.Ident str = ident
    if str /= "main" then pure ()
    else transBlock block

transArg :: Arabica.Abs.Arg -> InterpretingMonadIO ()
transArg x = case x of
  Arabica.Abs.Arg type_ ident -> failure x

transBlock :: Arabica.Abs.Block -> InterpretingMonadIO ()
transBlock x = case x of
  Arabica.Abs.Block stmts -> runStmts stmts
  where
    runStmts [] = pure ()
    runStmts (stmt:stmts) = do
      env <- get
      transStmt stmt
      runStmts stmts

transStmt :: Arabica.Abs.Stmt -> InterpretingMonadIO ()
transStmt x = case x of
  Arabica.Abs.Empty -> pure ()
  Arabica.Abs.BStmt block -> transBlock block
  Arabica.Abs.Decl type_ items -> do
    -- Na razie tylko int
    mapM_ transItem items
  Arabica.Abs.Ass ident expr -> do
    env <- get
    let locVal = runReaderT (transExpr expr) env
    case locVal of
      Nothing -> errorInterpretingMonadIO
      Just x -> put $ (M.insert ident x env)
  Arabica.Abs.ArrAss ident expr1 expr2 -> failure x
  Arabica.Abs.Incr ident -> failure x
  Arabica.Abs.Decr ident -> failure x
  Arabica.Abs.Ret expr -> failure x
  Arabica.Abs.VRet -> failure x
  Arabica.Abs.Cond expr stmt -> failure x
  Arabica.Abs.CondElse expr stmt1 stmt2 -> failure x
  Arabica.Abs.While expr stmt -> failure x
  Arabica.Abs.Break -> failure x
  Arabica.Abs.Continue -> failure x
  Arabica.Abs.SExp expr -> failure x
  Arabica.Abs.ForTo item expr stmt -> failure x
  Arabica.Abs.Print expr -> do
    -- Na razie tylko inty
    env <- get
    let locVal = runReaderT (transExpr expr) env
    case locVal of
      Just (Arabica.Abs.IntegerVal x) -> lift $ lift $ putStrLn $ show x
      _ -> errorInterpretingMonadIO

transItem :: Arabica.Abs.Item -> InterpretingMonadIO ()
transItem x = case x of
  Arabica.Abs.NoInit ident -> failure x
  Arabica.Abs.Init ident expr -> do
    -- Na razie tylko inty
    env <- get
    let locVal = runReaderT (transExpr expr) env
    case locVal of
      Just x -> put $ (M.insert ident x env)
      _ -> errorInterpretingMonadIO

transType :: Arabica.Abs.Type -> InterpretingMonadIO ()
transType x = case x of
  Arabica.Abs.Int -> failure x
  Arabica.Abs.Str -> failure x
  Arabica.Abs.Bool -> failure x
  Arabica.Abs.Void -> failure x
  Arabica.Abs.Fun type_ types -> failure x
  Arabica.Abs.Array type_ -> failure x

transExpr :: Arabica.Abs.Expr -> Result
transExpr x = case x of
  Arabica.Abs.EArray type_ integer -> errorExpM
  Arabica.Abs.EArrElem ident expr -> errorExpM
  Arabica.Abs.ELambda type_ args block -> errorExpM
  Arabica.Abs.EVar ident -> do
    env <- ask
    let val = M.lookup ident env
    case val of
      Just y -> pure y
      Nothing -> errorExpM
  Arabica.Abs.ELitInt integer -> pure $ Arabica.Abs.IntegerVal $ integer
  Arabica.Abs.ELitTrue -> pure $ Arabica.Abs.BoolVal $ True
  Arabica.Abs.ELitFalse -> pure $ Arabica.Abs.BoolVal $ False
  Arabica.Abs.EApp ident exprs -> errorExpM
  Arabica.Abs.EString string -> pure $ Arabica.Abs.StringVal $ string
  Arabica.Abs.Neg expr -> do
    Arabica.Abs.IntegerVal n <- transExpr expr
    pure $ Arabica.Abs.IntegerVal $ (-n)
  Arabica.Abs.Not expr -> do
    Arabica.Abs.BoolVal b <- transExpr expr
    pure $ Arabica.Abs.BoolVal $ not b
  Arabica.Abs.EMul expr1 mulop expr2 -> do
    Arabica.Abs.IntegerVal n1 <- transExpr expr1
    Arabica.Abs.IntegerVal n2 <- transExpr expr2
    transMulOp mulop n1 n2
  Arabica.Abs.EAdd expr1 addop expr2 -> do
    Arabica.Abs.IntegerVal n1 <- transExpr expr1
    Arabica.Abs.IntegerVal n2 <- transExpr expr2
    transAddOp addop n1 n2
  Arabica.Abs.ERel expr1 relop expr2 -> do
    Arabica.Abs.IntegerVal n1 <- transExpr expr1
    Arabica.Abs.IntegerVal n2 <- transExpr expr2
    transRelOp relop n1 n2
  Arabica.Abs.EAnd expr1 expr2 -> do
    Arabica.Abs.BoolVal b1 <- transExpr expr1
    Arabica.Abs.BoolVal b2 <- transExpr expr2
    pure $ Arabica.Abs.BoolVal $ b1 && b2
  Arabica.Abs.EOr expr1 expr2 -> do
    Arabica.Abs.BoolVal b1 <- transExpr expr1
    Arabica.Abs.BoolVal b2 <- transExpr expr2
    pure $ Arabica.Abs.BoolVal $ b1 || b2

transAddOp :: Arabica.Abs.AddOp -> Integer -> Integer -> Result
transAddOp x n1 n2 = case x of
  Arabica.Abs.Plus -> pure $ Arabica.Abs.IntegerVal $ n1 + n2
  Arabica.Abs.Minus -> pure $ Arabica.Abs.IntegerVal $ n1 - n2

transMulOp :: Arabica.Abs.MulOp -> Integer -> Integer -> Result
transMulOp x n1 n2 = case x of
  Arabica.Abs.Times -> pure $ Arabica.Abs.IntegerVal $ n1 * n2
  Arabica.Abs.Div -> do
    if n2 == 0 then
      errorExpM
    else
      pure $ Arabica.Abs.IntegerVal $ n1 `div` n2

transRelOp :: Arabica.Abs.RelOp -> Integer -> Integer -> Result
transRelOp x n1 n2 = case x of
  Arabica.Abs.LTH -> pure $ Arabica.Abs.BoolVal $ n1 < n2
  Arabica.Abs.LE -> pure $ Arabica.Abs.BoolVal $ n1 <= n2
  Arabica.Abs.GTH -> pure $ Arabica.Abs.BoolVal $ n1 > n2
  Arabica.Abs.GE -> pure $ Arabica.Abs.BoolVal $ n1 >= n2
  Arabica.Abs.EQU -> pure $ Arabica.Abs.BoolVal $ n1 == n2
  Arabica.Abs.NE -> pure $ Arabica.Abs.BoolVal $ n1 /= n2
