-- Haskell module generated by the BNF converter

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Arabica.Skel where

-- import Prelude (($), Either(..), String, (++), Show, show)
import qualified Arabica.Abs
import qualified Data.Map as M
import Arabica.Utils
import Arabica.Memory
import Data.Array
import Control.Monad.State
import Control.Monad.Reader

import Control.Monad.Trans.Maybe
import Control.Monad.Trans.Except

-- Bool - czy zmienna jest read-only
-- type VarEnv = M.Map Arabica.Abs.Ident (Arabica.Abs.Location, Bool)
-- type LocEnv = M.Map Arabica.Abs.Location Arabica.Abs.LocVal
-- type LocMemory = (LocEnv, Arabica.Abs.Location)
-- type ExpM a = ReaderT VarEnv Maybe a

type Err = Either String

assignArgsToVals :: Arabica.Abs.Ident -> [Arabica.Abs.Expr] -> [Arabica.Abs.Arg] -> Arabica.Abs.InterpretingMonadIO Arabica.Abs.VarEnv
assignArgsToVals _ [] [] = ask
assignArgsToVals ident _ [] = errorMessage $ Arabica.Abs.TooManyArgs ident
assignArgsToVals ident [] _ = errorMessage $ Arabica.Abs.NotEnoughArgs ident
assignArgsToVals ident (e:es) ((Arabica.Abs.Arg type_ ident_):as) = do
  val <- transExpr e
  newVarEnv <- newVariable False ident_ val
  local (const newVarEnv) $ assignArgsToVals ident es as

transIdent :: Arabica.Abs.Ident -> Arabica.Abs.InterpretingMonadIO ()
transIdent x = case x of
  Arabica.Abs.Ident string -> failure x

transProgram :: Arabica.Abs.Program -> Arabica.Abs.InterpretingMonadIO ()
transProgram x = case x of
  Arabica.Abs.Program topdefs -> do
    runTopDefs topdefs
  where
    runTopDefs [] = pure ()
    runTopDefs (def:defs) = do
      -- Czy powinniśmy przejmować się zwracaną wartością?
      (varEnv, _) <- transTopDef def
      local (const varEnv) $ runTopDefs defs

transTopDef :: Arabica.Abs.TopDef -> Arabica.Abs.InterpretingMonadIO (Arabica.Abs.VarEnv, Arabica.Abs.ReturnVal)
transTopDef x = case x of
  Arabica.Abs.FnDef type_ ident args block -> do
    -- Na razie tylko uruchamiaj main
    let Arabica.Abs.Ident str = ident
    newVarEnv <- newVariable False ident (Arabica.Abs.FunVal type_ args block M.empty)
    if str == "main" then  do
      (newestEnv, newestReturn, _) <- local (const newVarEnv) $ transBlock False block
      pure $ (newestEnv, newestReturn)
    else pure $ (newVarEnv, Nothing)

transArg :: Arabica.Abs.Arg -> Arabica.Abs.InterpretingMonadIO ()
transArg x = case x of
  Arabica.Abs.Arg type_ ident -> failure x

transBlock :: Bool -> Arabica.Abs.Block -> Arabica.Abs.InterpretingMonadIO Arabica.Abs.StmtState
transBlock inLoop x = case x of
  Arabica.Abs.Block stmts -> runStmts stmts
  where
    runStmts [] = normalPass
    runStmts (stmt:stmts) = do
      -- env <- ask
      -- (locEnv, _) <- get
      -- debugMessage $ unwords ["VARS", show env]
      -- debugMessage $ unwords ["LOCS", show locEnv]
      -- debugMessage $ unwords ["STATEMENT", show stmt]
      (newVarEnv, retVal, loopState) <- transStmt inLoop stmt
      case retVal of
        Just x -> pure $ (newVarEnv, retVal, loopState)
        Nothing -> do
          if inLoop then do
            case loopState of
              Arabica.Abs.NoLoopState -> local (const newVarEnv) $ runStmts stmts
              _ -> pure $ (newVarEnv, retVal, loopState)
          else local (const newVarEnv) $ runStmts stmts

-- Bool - czy jesteśmy w pętli
transStmt :: Bool -> Arabica.Abs.Stmt -> Arabica.Abs.InterpretingMonadIO Arabica.Abs.StmtState
transStmt inLoop x = case x of
  Arabica.Abs.Empty -> normalPass
  Arabica.Abs.BStmt block -> transBlock inLoop block
  Arabica.Abs.Decl type_ items -> do
    -- Na razie tylko int
    case items of
      [] -> normalPass
      (x:xs) -> do
        -- debugMessage $ unwords ["DECL", show (x:xs)]
        newVarEnv <- transItem False x
        local (const newVarEnv) $ transStmt inLoop (Arabica.Abs.Decl type_ xs)
  Arabica.Abs.Ass ident expr -> do
    -- env <- get
    -- let locVal = runReaderT (transExpr expr) env
    -- case locVal of
    --   Nothing -> errorArabica.Abs.InterpretingMonadIO
    --   Just x -> updateVariable ident x
    val <- transExpr expr
    updateVariable ident val
    normalPass
  Arabica.Abs.ArrAss ident posExpr valExpr -> do
    arrVal <- readVariable ident
    case arrVal of
      Arabica.Abs.ArrVal type_ arr -> do
        let (lowerBound, upperBound) = bounds arr
        position <- transExpr posExpr
        case position of
          Arabica.Abs.IntegerVal pos -> do
            if pos < lowerBound || pos > upperBound then do
              errorMessage $ Arabica.Abs.IndexOutOfBounds pos (lowerBound, upperBound) ident
            else do
              val <- transExpr valExpr
              if conformValType val type_ then do
                updateVariable ident $ Arabica.Abs.ArrVal type_ $ arr // [(pos, val)]
                normalPass
              else errorMessage $ Arabica.Abs.ArrayAssignMismatch ident
          _ -> errorMessage $ Arabica.Abs.IndexNotInteger ident
      _ -> errorMessage $ Arabica.Abs.NotAnArray ident
  Arabica.Abs.Incr ident -> failure "Incr"
  Arabica.Abs.Decr ident -> failure "Decr"
  Arabica.Abs.Ret expr -> do
    retVal <- transExpr expr
    varEnv <- ask
    pure $ (varEnv, Just retVal, Arabica.Abs.NoLoopState)
  Arabica.Abs.VRet -> do
    varEnv <- ask
    pure $ (varEnv, Just Arabica.Abs.VoidVal, Arabica.Abs.NoLoopState)
  Arabica.Abs.Cond expr stmt -> transStmt inLoop $ Arabica.Abs.CondElse expr stmt Arabica.Abs.Empty
  Arabica.Abs.CondElse expr stmt1 stmt2 -> do
    val <- transExpr expr
    -- Akceptujemy tylko inty i boole
    case val of
      Arabica.Abs.BoolVal b -> transStmt inLoop $ if' b stmt1 stmt2
      Arabica.Abs.IntegerVal n -> transStmt inLoop $ if' (n /= 0) stmt1 stmt2
  Arabica.Abs.While expr stmt -> do
    val <- transExpr expr
    -- TODO: Napisz to bez powtórzeń
    case val of
      Arabica.Abs.BoolVal b -> do
        if b then do
          (newVarEnv, retVal, loopState) <- transStmt True stmt
          case retVal of
            Just x -> pure $ (newVarEnv, retVal, loopState)
            Nothing -> do
              case loopState of
                Arabica.Abs.BreakState -> normalPass
                -- TODO: Czy tutaj inLoop czy może True? A może False xdd
                _ -> transStmt inLoop x
        else
          normalPass
      Arabica.Abs.IntegerVal n -> do
        if n /= 0 then do
          (newVarEnv, retVal, loopState) <- transStmt True stmt
          case retVal of
            Just x -> pure $ (newVarEnv, retVal, loopState)
            Nothing -> do
              case loopState of
                Arabica.Abs.BreakState -> normalPass
                -- TODO: Czy tutaj inLoop czy może True? A może False xdd
                _ -> transStmt inLoop x
        else
          normalPass
      _ -> failure "while"
  Arabica.Abs.Break -> do
    varEnv <- ask
    pure $ (varEnv, Nothing, Arabica.Abs.BreakState)
  Arabica.Abs.Continue -> do
    varEnv <- ask
    pure $ (varEnv, Nothing, Arabica.Abs.ContState)
  Arabica.Abs.SExp expr -> do
    transExpr expr
    normalPass
  Arabica.Abs.ForTo ident expr1 expr2 stmt -> do
    -- transItem True item
    -- val <- transExpr expr
    -- TODO: NIE DZIAŁA RETURN W PĘTLACH!!!!
    val1 <- transExpr expr1
    val2 <- transExpr expr2
    if (conformValType val1 Arabica.Abs.Int) && (conformValType val2 Arabica.Abs.Int) then do
      let Arabica.Abs.IntegerVal n1 = val1
      let Arabica.Abs.IntegerVal n2 = val2
      newVarEnv <- newVariable True ident val1
      local (const newVarEnv) $ runForLoop ident n1 n2 stmt
    else
      failure "ForTo"
    where
      runForLoop ident curr n2 stmt = do
        if curr == n2 then normalPass
        else do
          updateForVariable ident $ Arabica.Abs.IntegerVal curr
          (newVarEnv, retVal, loopState) <- transStmt True stmt
          case retVal of
            Just x -> pure $ (newVarEnv, retVal, loopState)
            Nothing -> do
              case loopState of
                Arabica.Abs.BreakState -> normalPass
                _ -> runForLoop ident (curr+1) n2 stmt
  Arabica.Abs.Print expr -> do
    -- Na razie tylko inty
    val <- transExpr expr
    case val of
      Arabica.Abs.IntegerVal n -> lift $ lift $ lift $ putStrLn $ show n
      Arabica.Abs.BoolVal b -> lift $ lift $ lift $ putStrLn $ show b
      Arabica.Abs.StringVal s -> lift $ lift $ lift $ putStrLn $ show s
      _ -> failure "Can only print integers, booleans and strings"
    normalPass

-- Bool - readonly?
transItem :: Bool -> Arabica.Abs.Item -> Arabica.Abs.InterpretingMonadIO Arabica.Abs.VarEnv
transItem readOnly x = case x of
  Arabica.Abs.NoInit ident -> failure "NoInit"
  Arabica.Abs.Init ident expr -> do
    val <- transExpr expr
    newVarEnv <- newVariable readOnly ident val
    -- debugMessage "INIT"
    pure $ newVarEnv

transType :: Arabica.Abs.Type -> Arabica.Abs.InterpretingMonadIO ()
transType x = case x of
  Arabica.Abs.Int -> failure x
  Arabica.Abs.Str -> failure x
  Arabica.Abs.Bool -> failure x
  Arabica.Abs.Void -> failure x
  Arabica.Abs.Fun type_ types -> failure x
  Arabica.Abs.Array type_ -> failure x

transExpr :: Arabica.Abs.Expr -> Arabica.Abs.InterpretingMonadIO Arabica.Abs.LocVal
transExpr x = case x of
  Arabica.Abs.EArray type_ integer -> do
    initVal <- defaultVal type_
    pure $ Arabica.Abs.ArrVal type_ (array (0, integer-1) [(ix, initVal) | ix <- [0..integer-1]])
  Arabica.Abs.EArrElem ident expr -> do
    val <- readVariable ident
    pos <- transExpr expr
    case val of
      Arabica.Abs.ArrVal type_ arr -> do
        let (lowerBound, upperBound) = bounds arr
        case pos of
          Arabica.Abs.IntegerVal n -> do
            if n < lowerBound || n > upperBound then do
              errorMessage $ Arabica.Abs.IndexOutOfBounds n (lowerBound, upperBound) ident
            else do
              pure $ arr ! n
      _ -> errorMessage $ Arabica.Abs.NotAnArray ident
  Arabica.Abs.ELambda type_ args block -> do
    varEnv <- ask
    closure <- getClosureFromCurrentEnvironment varEnv
    -- debugMessage $ unwords ["create function with args", show args]
    pure $ Arabica.Abs.FunVal type_ args block closure
  Arabica.Abs.EVar ident -> readVariable ident
  Arabica.Abs.ELitInt integer -> pure $ Arabica.Abs.IntegerVal $ integer
  Arabica.Abs.ELitTrue -> pure $ Arabica.Abs.BoolVal $ True
  Arabica.Abs.ELitFalse -> pure $ Arabica.Abs.BoolVal $ False
  Arabica.Abs.EApp ident exprs -> do
    varEnv <- ask
    maybeFun <- readVariable ident
    case maybeFun of
      -- TODO: closures
      Arabica.Abs.FunVal type_ args block closure -> do
        -- TODO: przyzwala na pozyskiwanie zmiennych z środowiska funkcji wywołującej, trzeba to zmienić
        -- i dodać rozróżnienie na funkcje i lambdy (ewentulanie dodać do FunVal środowisko)
        oldFunVarEnv <- assignArgsToVals ident exprs args
        funVarEnv <- local (const oldFunVarEnv) $ assignClosureToVals closure
        -- let funVarEnv = oldfunVarEnv
        -- debugMessage $ unwords ["apply function with environment", show funVarEnv]
        (_, retVal, _) <- local (const funVarEnv) $ transBlock False block
        case retVal of
          Just x -> pure x
          Nothing -> do
            case type_ of
              Arabica.Abs.Void -> pure Arabica.Abs.VoidVal
              _ -> errorMessage $ Arabica.Abs.NoValueReturned ident type_
      _ -> errorMessage $ Arabica.Abs.NotAFunction ident
  Arabica.Abs.EString string -> pure $ Arabica.Abs.StringVal $ string
  Arabica.Abs.Neg expr -> do
    Arabica.Abs.IntegerVal n <- transExpr expr
    pure $ Arabica.Abs.IntegerVal $ (-n)
  Arabica.Abs.Not expr -> do
    Arabica.Abs.BoolVal b <- transExpr expr
    pure $ Arabica.Abs.BoolVal $ not b
  Arabica.Abs.EMul expr1 mulop expr2 -> do
    Arabica.Abs.IntegerVal n1 <- transExpr expr1
    Arabica.Abs.IntegerVal n2 <- transExpr expr2
    transMulOp mulop n1 n2
  Arabica.Abs.EAdd expr1 addop expr2 -> do
    Arabica.Abs.IntegerVal n1 <- transExpr expr1
    Arabica.Abs.IntegerVal n2 <- transExpr expr2
    transAddOp addop n1 n2
  Arabica.Abs.ERel expr1 relop expr2 -> do
    Arabica.Abs.IntegerVal n1 <- transExpr expr1
    Arabica.Abs.IntegerVal n2 <- transExpr expr2
    transRelOp relop n1 n2
  Arabica.Abs.EAnd expr1 expr2 -> do
    Arabica.Abs.BoolVal b1 <- transExpr expr1
    Arabica.Abs.BoolVal b2 <- transExpr expr2
    pure $ Arabica.Abs.BoolVal $ b1 && b2
  Arabica.Abs.EOr expr1 expr2 -> do
    Arabica.Abs.BoolVal b1 <- transExpr expr1
    Arabica.Abs.BoolVal b2 <- transExpr expr2
    pure $ Arabica.Abs.BoolVal $ b1 || b2

transAddOp :: Arabica.Abs.AddOp -> Integer -> Integer -> Arabica.Abs.Result
transAddOp x n1 n2 = case x of
  Arabica.Abs.Plus -> pure $ Arabica.Abs.IntegerVal $ n1 + n2
  Arabica.Abs.Minus -> pure $ Arabica.Abs.IntegerVal $ n1 - n2

transMulOp :: Arabica.Abs.MulOp -> Integer -> Integer -> Arabica.Abs.Result
transMulOp x n1 n2 = case x of
  Arabica.Abs.Times -> pure $ Arabica.Abs.IntegerVal $ n1 * n2
  Arabica.Abs.Div -> do
    if n2 == 0 then
      errorMessage $ Arabica.Abs.DivisionByZero
    else
      pure $ Arabica.Abs.IntegerVal $ n1 `div` n2

transRelOp :: Arabica.Abs.RelOp -> Integer -> Integer -> Arabica.Abs.Result
transRelOp x n1 n2 = case x of
  Arabica.Abs.LTH -> pure $ Arabica.Abs.BoolVal $ n1 < n2
  Arabica.Abs.LE -> pure $ Arabica.Abs.BoolVal $ n1 <= n2
  Arabica.Abs.GTH -> pure $ Arabica.Abs.BoolVal $ n1 > n2
  Arabica.Abs.GE -> pure $ Arabica.Abs.BoolVal $ n1 >= n2
  Arabica.Abs.EQU -> pure $ Arabica.Abs.BoolVal $ n1 == n2
  Arabica.Abs.NE -> pure $ Arabica.Abs.BoolVal $ n1 /= n2
